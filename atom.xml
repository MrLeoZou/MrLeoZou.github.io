<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MrLeoZou</title>
  
  <subtitle>iOS开发者,大前端学习者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-15T14:17:02.735Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MrLeoZou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推演https的安全机制</title>
    <link href="http://yoursite.com/2018/03/15/%E6%8E%A8%E6%BC%94https%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/03/15/推演https的安全机制/</id>
    <published>2018-03-15T14:15:05.000Z</published>
    <updated>2018-03-15T14:17:02.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文将尝试使用一个反向推演的方式，从抛出问题，解决问题，出现新问题，解决新问题的思路，环环相扣，最后推演出https如何实现安全通信的，不过仅代表个人的理解，毕竟我一直也没看完《图解https》。</p><h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><ol><li>首先我们必须有一个最基本的需求：保证两端（客户端和服务端）的通信是安全的，也就是两者之间的通信内容有且只有通信双方能够获取并解析。</li><li>有了目标，该如何实现呢？很显然会想到加密，这也是目前行业内比较通用的解决方案。</li><li>不过加密算法如此之多，我们要怎么考量和选择呢？回到需求，我们需要的是双向安全，显然非对称加密不符合，因为它是单向安全的，因此我们很快锁定对称加密，毕竟也是通俗易懂接地气的。关于对称和非对称加密算法，不清楚的就需要自己先去了解下了，否则可能会影响往下的阅读和理解。</li><li>至此，好像我们的需求已经得到解决，这篇博文也就到此为止了。总感觉太奇怪了，毕竟我们不是这么短小的人🙄。</li></ol><h2 id="一对多的问题"><a href="#一对多的问题" class="headerlink" title="一对多的问题"></a>一对多的问题</h2><p>在上文中，我们愉快地解决了通信两端内容加密的需求，但忽略了一个重要的事实：现实中客户端和服务端并不是一对一的关系，往往都是一对多的关系，如果使用同一套对称加密算法，则如下图：<br><img src="推演https的安全机制/01.png" alt=""><br>这样一来，其实也就完全失去了加密的意义，因为大家用的都是同一套算法，可以互相解密了。因此，我们需要针对不同的客户端，协商不同的对称加密算法，保证客户端之间互相不能解密，如下图：<br><img src="推演https的安全机制/02.png" alt="图02"><br>那具体协商过程是怎样的呢？自然是通过服务器来告知客户端使用何种加密算法了。</p><h2 id="引入新的问题"><a href="#引入新的问题" class="headerlink" title="引入新的问题"></a>引入新的问题</h2><p>至此，我们已经知道两端通信安全需要使用对称加密来加密传输内容，但不同的客户端需要使用不同的对称加密算法，算法的协商过程由服务端告知客户端，那么问题来了：协商的过程也是不安全的，可能会被中间人拦截，也需要加密，应该怎么处理呢？</p><ol><li>首先想到的可能是对协商过程再加密就好了，但是，对协商过程的加密本身还是没有加密…，发现进入死循环了</li><li>为了解决这个死循环，我们需要引入一个新的方式，其实前面也提到过的：非对称加密</li></ol><h2 id="对协商过程加密"><a href="#对协商过程加密" class="headerlink" title="对协商过程加密"></a>对协商过程加密</h2><p>前面说到我们需要引入新的加密方式，因为对称加密会引发死循环的问题，那我们看下为什么要选择非对称加密？<br>非对称加密的特点：<strong>私钥加密后的密文，只要是公钥都可以解密；公钥加密后的密文，只有私钥可以解密；私钥只有一个人持有，而公钥可以发给所有人持有</strong><br><img src="推演https的安全机制/03.png" alt="图03"><br><strong>非对称加密是单向安全的，也就是说客户端向服务端方向是安全的，反之则是不安全的。</strong><br>至此，我们确定了使用非对称加密来加密协商过程，结合前文内容，我们知道目前需要使用到对称加密和非对称加密两种算法，事实上https也确实如此。</p><h2 id="具体怎么协商"><a href="#具体怎么协商" class="headerlink" title="具体怎么协商"></a>具体怎么协商</h2><p>我们需要对不同的客户端使用不同的对称加密算法，同时也不能让除两端之外的第3人知道，怎么保证足够安全和算法不确定性？<br><strong>使用随机数：使用随机数来生成对称加密算法，并且只有在交互的那一刻才能真正确定，这也就是为什么https在协议握手阶段会有这么多的随机数的原因了。</strong></p><h2 id="公钥从哪里来"><a href="#公钥从哪里来" class="headerlink" title="公钥从哪里来"></a>公钥从哪里来</h2><p>前面我们已经得出结论：使用非对称加密算法对协商过程加密，并且客户端持有公钥，服务端持有唯一的私钥。<br>这里出现了一个新的问题：客户端的公钥从哪里来？自然是服务端下发的，总不可能每个客户端/浏览器都本地提前保存一个服务端公钥吧，想想也不可能的。<br><strong><em>服务端下发？</em></strong><br>那岂不是又会出现传输不安全的问题嘛？难道这个下发过程又要加密，因为可能被篡改，这感觉又绕回去了最开始的死循环了…(懵逼脸)。<br><img src="推演https的安全机制/04.png" alt="图04"><br>我们设想一下，如果有一个全球公认的机构可以来帮我们下发公钥，因为大家对这些机构都是信任的，那客户端只需要判断是否是这些机构下发的，不就可以避免被中间人篡改的问题了，也就不需要循环加密了。<br>这就引出了证书机构和数字证书的概念了。<br><strong>我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。假如被中间人篡改，那客户端的三方机构公钥是不能正常解密的</strong><br>看下简化版的数字证书：（隐藏了其他信息的）<br><img src="推演https的安全机制/05.png" alt="图05"><br>再看下使用数字证书后的交互图：<br><img src="推演https的安全机制/06.png" alt="图06"><br>至此，我们已经解决了非对称加密公钥的安全获取，也就打通了使用非对称加密保障堆成加密算法的协商过程这一整套流程，看起来一切都是那么美好。</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>如果有了解过https的基本都知道还有一个重要的概念：数字签名。但是在上述的推演过程中我们并没有出现过，是不是遗漏了什么呢？<br>回到现实场景，我们确实遗漏了一点：第三方机构并不是只为一个公司制作证书的，机构和公司应该是一对多的关系，也就是说机构也会给中间人的公司发放证书。因此中间人还是可以对你的证书进行篡改，此时客户端并不能区分证书是来自你公司还是中间人，因为不论是你的证书还是中间人的，都是同一个三方机构颁发，客户端都可以正常解密。<br><img src="推演https的安全机制/07.png" alt="图07">  </p><h3 id="数字签名：解决同一机构颁发的证书被篡改的问题"><a href="#数字签名：解决同一机构颁发的证书被篡改的问题" class="headerlink" title="数字签名：解决同一机构颁发的证书被篡改的问题"></a>数字签名：解决同一机构颁发的证书被篡改的问题</h3><ol><li>首先解决一个问题：校验同一机构颁发的不同证书的工作应该放在哪里？服务端还是客户端？显然只能是客户端了，因为被篡改不可能发生在服务端，而是在服务端发送证书给客户端过程中，所以只能是客户端校验。</li><li>至于客户端如何验证，需要引入证书的另一个重要属性：证书编号，这就好比毕业证书的编号一样，是一个唯一标识。</li><li><strong>更重要的是，证书上不仅仅带有证书编号，还会写着如何根据证书的内容生成证书编号的方法，可以简单理解为一个MD5值。因此，客户端拿到这些信息后，在本地根据证书的方法生成一个证书编号，然后与证书上的编号进行比对，验证证书信息是否被篡改。同时，为了保证证书编号不被篡改，需要先使用机构的私钥加密后传递给客户端。（小提问：假如不做加密，直接传递MD5生成的证书编号，可能会有什么问题？）</strong></li><li>补充一点，上述情形下如果发生证书被中间人篡改，而且中间人使用同一个机构颁发的证书，那么客户端收到中间人的证书和其中包含的证书编号以及域名，服务器公钥等其他信息。然后按照证书的方法生成证书编号，肯定是和证书中的编号一致的，那岂不是推翻了我们刚刚说的结论？其实是因为我们前面只说了最重要的一点，比对证书编号；事实上还需要比对其他信息，包括域名对比等，这样结合起来就是全面的校验了。<br><img src="推演https的安全机制/08.png" alt="图08"> </li></ol><h2 id="最后的问题"><a href="#最后的问题" class="headerlink" title="最后的问题"></a>最后的问题</h2><p>至此，我们还留有最后一手，也是本文的最后一个问题，也就不卖关子了。<br><strong>三方机构的证书我们如何得到？</strong><br>真相只有一个：浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。<br><strong>三方机构如何颁布证书给服务器？</strong><br>这个就比较简单了，随便从网上给大家搬运一个流程。拿到证书后，剩下就是配置到公司服务器了。<br><img src="推演https的安全机制/09.png" alt="图09"><br><strong>为何不直接使用非对称加密传输？</strong><br>在引入证书以后，其实两端已经可以使用该非对称加密算法进行通信了，但我们还是坚持要协商出一个对称加密算法，并最终以该算法来做传输的加解密，原因很简单，文章开头也说到了，非对称加密只是单向安全的！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上文的推演，我们发现在真正建立安全传输之前，已经需要做非常多的工作（SSL/TLS）,目的就是为了协商出一个对称加密算法，在此之后就可以使用该加密算法愉快地传输和加密解密了。<br>这其实也可以反映出为什么https对比http多了这么多交互，效率也下降了不少，一切都是为了安全！<br><strong>总结来说：为了保证两端安全传输，需要对传输内容进行对称加密；但是由于不同客户端需要协商不同的对称加密算法，协商的过程需要使用非对称加密；非对称加密中服务端需要给客户端下发公钥，此过程也是不安全的，需要使用机构的三方私钥加密，也就是数字证书，之后客户端通过保存在本地的机构公钥对证书进行解密，校验等，最后获取到服务器下发的公钥，并进行上述的协商过程。</strong>（就酱吧，好累(╯﹏╰)）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文将尝试使用一个反向推演的方式，从抛出问题，解决问题，出现新问题，解决新问题的思路，环环相扣，最后推演出https如何实现安全通信的，不过
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>深入理解RunLoop</title>
    <link href="http://yoursite.com/2017/12/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop/"/>
    <id>http://yoursite.com/2017/12/11/深入理解RunLoop/</id>
    <published>2017-12-11T05:25:11.000Z</published>
    <updated>2017-12-11T05:39:43.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>回想下，大家在日常开发中是否有以下疑问：</p><blockquote><p><strong>1.基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？<br>2.延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的嘛？<br>3.事件响应和手势识别底层处理是一致的嘛，为什么？<br>4.界面刷新，setlayoutIfneed等，是在什么时候会真正执行刷新，为什么会刷新不及时？<br>5.项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？<br>6.当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？</strong></p></blockquote><p>很多时候我们都是只关心或者记住了这样写就能有预期的效果，却不关心内部原理，从而在出现bug时不知道如何调试，自然也不能很好地阐述为什么要这样实现。只知其然而不知其所以然，本文目的就是和大家一起破解『其所以然』。</p><h2 id="RunLoop详解"><a href="#RunLoop详解" class="headerlink" title="RunLoop详解"></a>RunLoop详解</h2><h3 id="RunLoop机制"><a href="#RunLoop机制" class="headerlink" title="RunLoop机制"></a>RunLoop机制</h3><p>1、首先引入一个概念：<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event_loop</a>，一般一个线程执行完任务后就会退出，当需要保证该线程不退出，可以通过类似以下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function do_loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开启一个循环，保证线程不退出，这就是Event_loop模型。这是在很多操作系统中都使用的模型，例如OS/iOS中的RunLoop。这种模型最大的作用就是管理事件/消息，在有新消息到来时立刻唤醒处理，没有待处理消息时线程休眠，避免资源浪费。</p><p>2、在OSX/iOS中，RunLoop就是这样一个管理对象，首先会对外提供一个上述的入口函数来开启循环，随后开始接收处理消息，并一直处于函数内部”接收消息 -&gt; 处理 -&gt; 等待”的循环中，直到接收结束消息，循环结束。</p><p>3、OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。<br>其中CFRunLoopRef是开源的，可以在<a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a>下载源码查看。</p><hr><blockquote><p>由于CoreFoundation是开源的，接下来的底层分析大部分是基于CFRunLoopRef来展开的</p></blockquote><h4 id="RunLoop对外接口"><a href="#RunLoop对外接口" class="headerlink" title="RunLoop对外接口"></a>RunLoop对外接口</h4><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p><blockquote><p>CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef</p></blockquote><p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p><p><img src="http://upload-images.jianshu.io/upload_images/674591-8e270edaeb053518.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_0.png"><br>记住下面几句话：</p><blockquote><p><strong>一个RunLoop里面可以有多个Mode<br>一个Mode里面可以有多个Source/Observer/Timer<br>每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode<br>如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入，这样做是为了分隔不同组的Source/Observer/Timer，互不影响。</strong></p></blockquote><p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方，有两种Source:Source0 和 Source1。<br>•Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。<br>• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</p><p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p><p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p><hr><h3 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h3><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p><blockquote><p>后面解答问题将会用到这个概念</p></blockquote><p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure></p><p>Mode 暴露的管理 mode item 的接口有下面几个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure></p><p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。<br>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p><hr><h3 id="RunLoop的内部实现"><a href="#RunLoop的内部实现" class="headerlink" title="RunLoop的内部实现"></a>RunLoop的内部实现</h3><p>参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">官方文档</a>说明，RunLoop 内部的逻辑大致如下:</p><p><img src="http://upload-images.jianshu.io/upload_images/674591-cd32e5aa139bea59.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="runloop.jpg"><br>转换成更完善的版本：</p><p><img src="http://upload-images.jianshu.io/upload_images/674591-3502b5461a4f8627.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_1.png"></p><blockquote><p>实际上 RunLoop 就是Event_loop函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p></blockquote><hr><h3 id="RunLoop底层技术"><a href="#RunLoop底层技术" class="headerlink" title="RunLoop底层技术"></a>RunLoop底层技术</h3><p>从文档中我们还可以知道，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构<br><img src="http://upload-images.jianshu.io/upload_images/674591-523a916a2ebf3e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_3.png"><br>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>应用框架层即开发人员接触到的 Cocoa 等框架。<br>核心框架层包括各种核心框架、OpenGL 等内容。<br>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容。</p><p>我们在深入看一下 Darwin 这个核心的架构：</p><p><img src="http://upload-images.jianshu.io/upload_images/674591-a1420294376d71ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Darwin.png"><br>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit ，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。<br>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。<br>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作。</p><p><img src="http://upload-images.jianshu.io/upload_images/674591-6553b68e7df82dda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" Mach 陷阱 (trap).png"></p><p>RunLoop 的核心就是一个 mach_msg() ，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p><blockquote><p>上述知识点比较晦涩难懂，仅需作为了解，知道内核调用过程。以上知识点均可参考：<br><a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/System_call</a><br><a href="https://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Trap_(computing)</a>)<br><a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="noopener">http://nshipster.com/inter-process-communication/</a></p></blockquote><hr><h2 id="iOS程序中RunLoop的处理"><a href="#iOS程序中RunLoop的处理" class="headerlink" title="iOS程序中RunLoop的处理"></a>iOS程序中RunLoop的处理</h2><p>首先看一下在APP启动之初，RunLoop做了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到，系统默认注册了5个Mode:<br>1.kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。<br>2.UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。<br>3.UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。<br>4.GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。<br>5.kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</p></blockquote><p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="noopener">http://iphonedevwiki.net/index.php/CFRunLoop</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中基本用不到。</p><hr><h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。虽然苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p><p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">/// 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">/// 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        /// 取不到时，创建一个</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p></blockquote><h2 id="解决问题：（RunLoop在iOS中的运用）"><a href="#解决问题：（RunLoop在iOS中的运用）" class="headerlink" title="解决问题：（RunLoop在iOS中的运用）"></a>解决问题：（RunLoop在iOS中的运用）</h2><h3 id="1-基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？"><a href="#1-基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？" class="headerlink" title="1.基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？"></a>1.基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？</h3><h4 id="CommonModes："><a href="#CommonModes：" class="headerlink" title="CommonModes："></a>CommonModes：</h4><p>一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。<br>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p><blockquote><p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p></blockquote><h4 id="定时器NSTimer："><a href="#定时器NSTimer：" class="headerlink" title="定时器NSTimer："></a>定时器NSTimer：</h4><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 8:00, 8:10, 8:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 8:00 时错过了那个点的公交，那只能等 8:10 这一趟了。</p><h3 id="2-延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的嘛？"><a href="#2-延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的嘛？" class="headerlink" title="2.延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的嘛？"></a>2.延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的嘛？</h3><h4 id="performSelecter："><a href="#performSelecter：" class="headerlink" title="performSelecter："></a>performSelecter：</h4><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="3-事件响应和手势识别底层处理是一致的嘛，为什么？"><a href="#3-事件响应和手势识别底层处理是一致的嘛，为什么？" class="headerlink" title="3.事件响应和手势识别底层处理是一致的嘛，为什么？"></a>3.事件响应和手势识别底层处理是一致的嘛，为什么？</h3><h4 id="事件响应："><a href="#事件响应：" class="headerlink" title="事件响应："></a>事件响应：</h4><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h4 id="手势识别："><a href="#手势识别：" class="headerlink" title="手势识别："></a>手势识别：</h4><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="4-界面刷新，setlayoutIfneed等，是在什么时候会真正执行刷新，为什么会刷新不及时？"><a href="#4-界面刷新，setlayoutIfneed等，是在什么时候会真正执行刷新，为什么会刷新不及时？" class="headerlink" title="4.界面刷新，setlayoutIfneed等，是在什么时候会真正执行刷新，为什么会刷新不及时？"></a>4.界面刷新，setlayoutIfneed等，是在什么时候会真正执行刷新，为什么会刷新不及时？</h3><h4 id="界面刷新："><a href="#界面刷新：" class="headerlink" title="界面刷新："></a>界面刷新：</h4><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数:_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。<strong>所以说界面刷新并不一定是在setNeedsLayout相关的代码执行后立刻进行的。</strong></p><h3 id="5-项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？"><a href="#5-项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？" class="headerlink" title="5.项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？"></a>5.项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？</h3><h4 id="AutoreleasePool："><a href="#AutoreleasePool：" class="headerlink" title="AutoreleasePool："></a>AutoreleasePool：</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><blockquote><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，一般情况下开发者也不必显示创建 Pool 了。</p></blockquote><hr><h3 id="RunLoop在GCD和网络请求中的使用"><a href="#RunLoop在GCD和网络请求中的使用" class="headerlink" title="RunLoop在GCD和网络请求中的使用"></a>RunLoop在GCD和网络请求中的使用</h3><h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h4 id="NSURLConnection"><a href="#NSURLConnection" class="headerlink" title="NSURLConnection"></a>NSURLConnection</h4><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><p><img src="http://upload-images.jianshu.io/upload_images/674591-f5e37b0c4ceb51af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RunLoop_network.png"><br>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h3 id="6-当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？"><a href="#6-当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？" class="headerlink" title="6.当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？"></a>6.当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？</h3><blockquote><p>这个在文章开头其实就已经揭晓答案了，开启一个RunLoop保证线程不退出即可。</p></blockquote><hr><h3 id="RunLoop与线程保活"><a href="#RunLoop与线程保活" class="headerlink" title="RunLoop与线程保活"></a>RunLoop与线程保活</h3><p>至此，对于RunLoop的内部实现，底层原理，iOS中的运用等我们都又有了一些分析，但是应该还有一些关键点没有明确，例如：</p><blockquote><p>1.使用RunLoop线程保活具体是怎么实现的呢，有什么需要关注的点<br>2.RunLoop的启动和退出是发送在哪个时间?<br>3.RunLoop的退出（Exit）和终结（terminate）有什么区别?</p></blockquote><p>关于以上几点，相信<a href="http://www.jianshu.com/p/10121d699c32" target="_blank" rel="noopener">这篇文章</a>会有你满意的答案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">Run Loops 官方文档</a><br><a href="http://www.jianshu.com/p/10121d699c32" target="_blank" rel="noopener">深入研究 Runloop 与线程保活</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;回想下，大家在日常开发中是否有以下疑问：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.基于NSTimer的轮播器什么情况下会
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>理解@property使用的关键字</title>
    <link href="http://yoursite.com/2017/12/11/%E7%90%86%E8%A7%A3-property%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/12/11/理解-property使用的关键字/</id>
    <published>2017-12-11T02:57:43.000Z</published>
    <updated>2017-12-11T03:07:12.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>@property是什么<br>众所周知，在iOS开发中，@property是用来声明属性的，默认会自动创建该属性的存储器以及带下划线的成员变量。对于紧随其后的那些关键字也是烂熟于心，信手拈来，但是会用并不代表知道为什么要这样用。</p><h2 id="小Tip"><a href="#小Tip" class="headerlink" title="小Tip"></a>小Tip</h2><h3 id="属性和变量"><a href="#属性和变量" class="headerlink" title="属性和变量"></a>属性和变量</h3><p>在项目中常见的两种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Test : NSObject</span><br><span class="line">&#123;</span><br><span class="line">// 声明变量</span><br><span class="line">NSString *testName;</span><br><span class="line">NSString *testType;</span><br><span class="line">&#125;</span><br><span class="line">// 声明属性</span><br><span class="line">@property(nonatomic,strong) NSString *testName;</span><br><span class="line">@property(nonatomic,strong) NSString *testType;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>以上两种声明的区别在于：<br>（1）声明变量时没有使用到@property，而声明属性时需要用到<br>（2）使用@property声明的属性，默认会自动生成属性的存取器，也就是getter/setter方法，以及带下划线的成员变量；而单独声明变量则没有前者特性。</p><hr><h2 id="property的关键字"><a href="#property的关键字" class="headerlink" title="@property的关键字"></a>@property的关键字</h2><blockquote><p>从大体上我们可以归为三类：原子性，存取控制，内存管理</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="atomic-nonatomic"><a href="#atomic-nonatomic" class="headerlink" title="atomic | nonatomic"></a>atomic | nonatomic</h4><p><strong>1. atomic</strong>:原子性，同一时刻只能有一个线程能访问该属性，在进行属性的get/set时候是安全的。也就是说atomic只能在一定程度上保证线程安全，并不是一定的线程安全。</p><blockquote><p>因为原子属性是保证同一时刻只能有一个线程操作该对象，但是不能保证在一次完整的set -&gt; get操作过程中，只有同一个线程操作。比如，线程A先set该属性，完成后线程B也set了该属性，改变了原来的值，在B完成后A再进行get操作，此时会发现属性的值已经不是当初A线程set进去的，因此会有问题。另外一种更极端的情况是在A线程set完成，B线程进入把该对象release了，等A线程再来访问时就会导致crash。所以想要真正的线程安全，还是需要使用到加锁来实现，具体实现就不在本文的讨论范围了。</p></blockquote><p><strong> 2. nonatomic</strong> :非原子性，顾名思义也就是和atomic含义是相反的。不保证线程安全，可以多个线程同时访问。</p><blockquote><p>小结：在日常开发中，我们绝大部分时候都是使用nonatomic，最主要的原因是nonatomic效率比atomic高很多（坊间传闻约快20倍，具体没有去验证过），因此，在明确只有一个线程访问的情况下推荐使用nonatomic。但是，并不是说任何时候都是用nonatomic，具体要根据实际情况，如果某属性确实存在线程不安全的问题，还是要考虑使用atomic的。</p></blockquote><hr><h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><h4 id="readwrite-readonly-writeonly"><a href="#readwrite-readonly-writeonly" class="headerlink" title="readwrite | readonly | writeonly"></a>readwrite | readonly | writeonly</h4><ol><li><p>readwrite：可读可写，默认值。同时拥有getter和setter方法</p></li><li><p>readonly：可读不可写，只有getter没有setter方法</p></li><li><p>writeonly：可写不可读，只有setter没有getter方法，很少使用</p></li></ol><p>相对来说，这几个关键字是很简单也容易理解的。</p><hr><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="strong-weak-unsafe-unretained-assign-retain-copy"><a href="#strong-weak-unsafe-unretained-assign-retain-copy" class="headerlink" title="strong | weak | unsafe_unretained | assign | retain | copy"></a>strong | weak | unsafe_unretained | assign | retain | copy</h4><p><strong>1. assign:</strong><br>（1）默认值，用于修饰值类型（基本数据类型），如：int，float，double，CGFloat，NSInteger等。另外就是不存在所有权关系的对象，如：delegate。<br>（2）assign修饰的属性不牵涉内存管理，不会被引用计数器管理。</p><p><strong>2. retain:</strong><br>  ARC后用于取代retain的，作用等同于retain。表示实例变量对传入的对象要有所有权关系，也就是强引用。</p><p><strong>3. strong:</strong><br>ARC后用于取代retain的，作用等同于retain。表示实例变量对传入的对象要有所有权关系，也就是强引用。</p><p><strong>4. weak:</strong><br>针对对象类型，在setter方法中，不会对传入的对象执行引用计数器+1的操作。也就是对传入的对象没有所有权，是弱引用。另外当传入的对象引用计数器为0，也就是被释放后，用weak声明的实例变量会指向nil，即空对象。</p><p><strong>5. unsafe_unretained:</strong><br>（1）从字面上来看，我们可以拆分成两部分来理解，unretained和retain相反，也就是和strong相反，因此等同于weak，其实也是用在iOS5之前替代weak使用的<br>（2）unsafe，不安全的，如上所述等同于weak的话那应该是安全的，这里不安全的是指当传入的对象被释放后，使用unsafe_unretained修饰的变量是不知道的，也不会像weak一样指向nil，所以此时访问可能会引起crash。因此，总结来说unsafe_unretained作用是等同于weak，但是是不安全的。</p><p><strong>6. copy:</strong>在不同情况下会有不同的操作<br>（1）传入的对象是不可变的，如NSString对象<br>  A. 强引用传进来的对象，使其引用计数器+1，等同于strong<br>  B. 该变量指向地址和传入对象的指向地址一致<br>（2）传入对象是可变对象，如NSMutableString对象<br>A. 拷贝一份传入对象，生成一个新的对象，值等同于传入对象值，但是不会强引用传入对象<br>B. 此时变量指向地址就是上述生成的新对象地址，与传入对象地址无关，也不相同；因此，传入对象改变也不会影响到当前变量的值，两者已经是不相干的两个对象了。</p><blockquote><p>关于copy更多深入分析 <a href="http://southpeak.github.io/2015/05/10/ios-techset-1/" target="_blank" rel="noopener">请参考此文</a></p></blockquote><hr><h3 id="几个常见问题"><a href="#几个常见问题" class="headerlink" title="几个常见问题"></a>几个常见问题</h3><h4 id="unsafe-unretained、weak、assign-的区别？"><a href="#unsafe-unretained、weak、assign-的区别？" class="headerlink" title="unsafe_unretained、weak、assign 的区别？"></a>unsafe_unretained、weak、assign 的区别？</h4><ol><li>三者都不会对引用计数器进行操作，都不是对象的拥有者</li><li>unsafe_unretained作用等同于weak，但其实不安全的，不会对传入的对象做赋nil处理，可能产生野指针。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) NSString *strongString;</span><br><span class="line">@property(nonatomic, unsafe_unretained) NSString *unsafe_unretainedString;</span><br><span class="line">self.strongString= [[NSStringalloc] initWithString:&quot;strongString&quot;];</span><br><span class="line">self.unsafe_unretainedString=self.strongString;</span><br><span class="line">self.strongString=nil;</span><br><span class="line">NSLog(@&quot;unsafe_unretainedString == %@&quot;,self.unsafe_unretainedString);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这时打印unsafe_unretainedString的值时程序会crash掉。原因是strongString已经释放掉了，但是unsafe_unretainedString并不知道已被释放，所以造成了unsafe_unretainedString访问野指针的内存。</p></blockquote><p>3.assign用于修饰值类型或id，当被释放后如果不手动赋nil，会产生野指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) NSString *strongString;</span><br><span class="line">@property(nonatomic,assign) NSString *assignString;</span><br><span class="line">self.strongString= [[NSString alloc] initWithString:&quot;strongString&quot;];</span><br><span class="line">self.assignString=self.strongString;</span><br><span class="line">self.strongString=nil;</span><br><span class="line">NSLog(@&quot;assignString == %@&quot;,self.assignString);</span><br></pre></td></tr></table></figure></p><blockquote><p>assign的问题和unsafe_unretained类似，可能会产生野指针。</p></blockquote><p>4.weak修饰的变量，当传入的对象被释放后，会自动指向nil，不会产生野指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) NSString *strongString;</span><br><span class="line">@property(nonatomic,weak) NSString *weakString;</span><br><span class="line">self.strongString= [[NSStringalloc] initWithString:&quot;strongString&quot;];</span><br><span class="line">self.weakString=self.strongString;</span><br><span class="line">self.strongString=nil;</span><br><span class="line">NSLog(@&quot;weakString == %@&quot;,self.weakString);</span><br></pre></td></tr></table></figure></p><blockquote><p>由于 self.strongString与self.weakString指向同一地址，且self.weakString没有retain内存地址，而self.strongString =nil释放 了内存，所以self.strongString为nil。由于self.weakString声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为nil。这样的好处能有效的防止野指针。</p></blockquote><hr><h4 id="delegate使用assign还是weak，为什么？"><a href="#delegate使用assign还是weak，为什么？" class="headerlink" title="delegate使用assign还是weak，为什么？"></a>delegate使用assign还是weak，为什么？</h4><ol><li>理论上来说，两者都是可以使用的，其一，都不会操作delegate的引用计数器，不是强引用对象。其二，在实际开发中，几乎所有场景下，delegate所指向的对象A的生存期都会被delegate变量B自身的生存期覆盖，也就是说A在使用B的过程中，B都是存在的，因此使用assign也不会有问题。</li><li>但是，由于assign不会处理delegate被释放后的情况，上述的也只是大部分情况，不排除可能会出现delegate被释放了而A还在使用，产生野指针错误，而weak正好会处理这个情况，因此我们一般使用weak来修饰delegate，会更加安全</li></ol><hr><h4 id="self对象是被strong，weak还是其他关键字修饰的？"><a href="#self对象是被strong，weak还是其他关键字修饰的？" class="headerlink" title="self对象是被strong，weak还是其他关键字修饰的？"></a>self对象是被strong，weak还是其他关键字修饰的？</h4><blockquote><p>在实际开发中，我们随处可见[self testMothod];这种写法，但是真正去思考self的生命周期和内存管理的估计很少。试问假如self在方法执行的过程中被释放了，会发生什么？</p></blockquote><p>通过 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self" target="_blank" rel="noopener">查阅clang文档</a>，我们发现了关于self的解释：</p><blockquote><p>The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object.<br>To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method.<br>Rationale<br>The cost of retaining self in all methods was found to be prohibitive, as it tends to be live across calls, preventing the optimizer from proving that the retain and release are unnecessary — for good reason, as it’s quite possible in theory to cause an object to be deallocated during its execution without this retain and release. Since it’s extremely uncommon to actually do so, even unintentionally, and since there’s no natural way for the programmer to remove this retain/release pair otherwise (as there is for other parameters by, say, making the variable __unsafe_unretained), we chose to make this optimizing assumption and shift some amount of risk to the user.</p></blockquote><p>上述，self既不是strong也不是weak，而是被unsafe_unretained修饰的，因此要求我们调用的时候保证self是存在的，否则可能会引起无法预料的crash。这样设计的原因是因为在对象方法调用时，我们一定是会把self传递进去，并且在绝大部分情况下做为调用方，我们不会把self释放掉，如果为了处理不到1%情况下的异常而在方法执行时增加retain和release进行保护的话，会对性能有重大影响，因此ARC设计也就没有帮我们处理，需要调用方自行保证self的存在。</p><blockquote><p>以上便是对iOS常用的property后关键字的分析理解。另外，关于copy和block的使用和探讨将在后续的文章进行，这块较复杂内容也较多。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;@property是什么&lt;br&gt;众所周知，在iOS开发中，@property是用来声明属性的，默认会自动创建该属性的存储器以及带下划线的成员
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中的各种锁</title>
    <link href="http://yoursite.com/2017/12/11/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <id>http://yoursite.com/2017/12/11/iOS开发中的各种锁/</id>
    <published>2017-12-11T01:47:05.000Z</published>
    <updated>2017-12-11T02:49:33.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>平常项目开发中需要手动加锁的地方少之又少，而且一般是简单粗暴使用@synchronized搞定，不过打算封装框架时就会发现远不满足。本文的目的是希望站在iOS开发中锁的使用之上的层面分析，探讨各种加锁方式的大致实现原理以及它们之间的区别和性能对比。由于加锁必然涉及到多线程相关知识，所以本文涉猎的知识点可能较多，本着相互学习探讨的心态，希望大家多多指正。</p><p>首先借鉴一张ibireme各种锁性能对比图镇楼，同时也是我们本文的叙述脉络：</p><p><img src="/2017/12/11/iOS开发中的各种锁/lock_01.png" alt="来源：ibireme"><br>上图，Y轴从下到上性能越来越来，越来越接近底层，平时使用也越来越少o(╯□╰)o。接下来我们将从我们最熟悉的@synchronized说起，逐步深入，步步为营。</p><hr><p>在开始分析之前，有几个概念需要先拎出来溜溜，方便后文理解。</p><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p> <a href="http://baike.baidu.com/view/3186651.htm" target="_blank" rel="noopener">时间片轮转调度算法</a><br>这是目前操作系统中大量使用的线程管理方式，大致就是操作系统会给每个线程分配一段时间片（通常100ms左右）这些线程都被放在一个队列中，cpu只需要维护这个队列，当队首的线程时间片耗尽就会被强制放到队尾等待，然后提取下一个队首线程执行。</p><hr><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>“原子”：一般指最小粒度，不可分割；原子操作也就是不可分割，不可中断的操作。我们最重要是知道这个概念，至于具体实现就不在本文的讨论范围。可以参考以下文章：<br><a href="http://www.jianshu.com/p/cb7b726e943c" target="_blank" rel="noopener">原子操作01</a><br><a href="http://southpeak.github.io/2014/10/17/osatomic-operation/" target="_blank" rel="noopener">原子操作02</a><br>至此，我们正式进入iOS开发中各种锁的探讨。</p><hr><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h2><p>显然，这是我们最熟悉的加锁方式，因为这是OC层面的为我们封装的，使用起来简单粗暴。使用时 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(也就是锁池)，通过对对象去哈希值来得到对应的互斥锁。<br>对于@synchronized更深入的实现理解，这里<a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">@synchronized</a>会有更好的答案。</p><hr><h2 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock 自旋锁"></a>OSSpinLock 自旋锁</h2><p>首选作为效率最优选择的OSSpinLock是自旋锁，在 bireme 的<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a>文中，已经指出潜在的bug：优先级反转，因此目前不建议使用。<a href="http://baike.baidu.com/link?url=T9Im_xVyniC5SdvZVH1Y1iEgkFhcjGm-Hnme803oWgRi3vZa1JVMy-RsljCPDuvPiOcWIrrUedw7CLYRjqhWtuO4CLSgugUUPoHrCKsB-T2GNionyGgXYRUaJ43joO6ZeGGvxIDsW6s2ham_x1vkv_" target="_blank" rel="noopener">什么是优先级反转？</a><br>自旋锁的目的是为了确保临界区只有一个线程可以访问，自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，自旋锁是使用忙等机制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁</span><br><span class="line">do &#123;</span><br><span class="line">while(test_and_set(&amp;lock); // test_and_set 是一个原子操作</span><br><span class="line">Critical section  // 临界区</span><br><span class="line">lock = false; // 相当于释放锁，这样别的线程可以进入临界区</span><br><span class="line">Reminder section // 不需要锁保护的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果临界区的执行时间过长，不建议使用自旋锁，因为在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。</p><hr><h2 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore  信号量"></a>dispatch_semaphore  信号量</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p><strong>dispatch_semaphore_create(1)：</strong>传入值必须&gt;=0, 若传入为0则阻塞线程并等待timeout,时间到后会执行其后的语句<br><strong>dispatch_semaphore_wait(signal, overTime)：</strong>可以理解为lock,会使得signal值-1<br><strong>dispatch_semaphore_signal(signal)：</strong>可以理解为unlock,会使得signal值+1</p></blockquote><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote><p>停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。<br><strong>信号量的值（signal）</strong>就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，dispatch_semaphore_signal就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），调用一次 dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait 剩余车位就减少一个；当剩余车位为 0 时，再来车（即调用 dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，所以就一直等下去。</p></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>参考<a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">介绍 GCD 底层实现的文章</a>中简单描述了信号量 dispatch_semaphore_t 的实现原理，它最终会调用到 sem_wait 方法，这个方法在 <a href="http://www.gnu.org/software/libc/" target="_blank" rel="noopener">glibc</a> 中被实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sem_wait (sem_t *sem) &#123;</span><br><span class="line">  int *futex = (int *) sem;</span><br><span class="line">  if (atomic_decrement_if_positive (futex) &gt; 0)</span><br><span class="line">    return 0;</span><br><span class="line">  int err = lll_futex_wait (futex, 0);</span><br><span class="line">    return -1;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><blockquote><p>首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在lll_futex_wait<br>函数中实现，<strong>lll</strong> 是 low level lock 的简称。这个函数通过汇编代码实现，调用到SYS_futex<br>这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。<br>主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。<br>可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</p></blockquote><h2 id="pthread-mutex-互斥锁"><a href="#pthread-mutex-互斥锁" class="headerlink" title="pthread_mutex 互斥锁"></a>pthread_mutex 互斥锁</h2><p>pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁</span><br><span class="line">pthread_mutex_lock(&amp;mutex); // 申请锁</span><br><span class="line">    // 临界区</span><br><span class="line">pthread_mutex_unlock(&amp;mutex); // 释放锁</span><br></pre></td></tr></table></figure><h3 id="互斥锁的实现"><a href="#互斥锁的实现" class="headerlink" title="互斥锁的实现"></a>互斥锁的实现</h3><blockquote><p>互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。<br>上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test_and_test，这样可以在错误使用互斥锁时提高性能。</p></blockquote><hr><h2 id="pthread-mutex-recursive-递归锁"><a href="#pthread-mutex-recursive-递归锁" class="headerlink" title="pthread_mutex(recursive)  递归锁"></a>pthread_mutex(recursive)  递归锁</h2><p>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。<br>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己，由此也就引出了递归锁：<strong>允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。</strong></p><p>递归锁的使用和pthread_mutex很类似，主要就是要设置锁的类型为PTHREAD_MUTEX_RECURSIVE即可。</p><blockquote><p>由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。</p></blockquote><hr><h2 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h2><p>NSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define    MLOCK \</span><br><span class="line">- (void) lock\</span><br><span class="line">&#123;\</span><br><span class="line">  int err = pthread_mutex_lock(&amp;_mutex);\</span><br><span class="line">  // 错误处理 ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>NSLock只是在内部封装了一个pthread_mutex，属性为PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部pthread_mutex互斥锁的类型不同。通过宏定义，可以简化方法的定义。<br>NSLock比pthread_mutex略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p><hr><h2 id="NSRecursiveLock-递归锁"><a href="#NSRecursiveLock-递归锁" class="headerlink" title="NSRecursiveLock 递归锁"></a>NSRecursiveLock 递归锁</h2><p>前文我们已经介绍过，递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型。NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE。</p><hr><h2 id="NSConditionLock-条件锁"><a href="#NSConditionLock-条件锁" class="headerlink" title="NSConditionLock 条件锁"></a>NSConditionLock 条件锁</h2><p>NSCondition的底层是通过条件变量(condition variable)pthread_cond_t来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。<a href="https://zh.wikipedia.org/wiki/生产者消费者问题" target="_blank" rel="noopener">关于生产者消费者问题</a></p><h3 id="条件变量使用"><a href="#条件变量使用" class="headerlink" title="条件变量使用"></a>条件变量使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void consumer () &#123; // 消费者</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while (data == NULL) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据</span><br><span class="line">    &#125;</span><br><span class="line">    // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓</span><br><span class="line">    // temp = data;</span><br><span class="line">    // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void producer () &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    // 生产数据</span><br><span class="line">    pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，告诉他们有了新的数据</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。</p><h3 id="这也就是NSCondition的实现原理："><a href="#这也就是NSCondition的实现原理：" class="headerlink" title="这也就是NSCondition的实现原理："></a>这也就是NSCondition的实现原理：</h3><p>NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者。NSCondition的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void) signal &#123;</span><br><span class="line">  pthread_cond_signal(&amp;_condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其实这个函数是通过宏来定义的，展开后就是这样</span><br><span class="line">- (void) lock &#123;</span><br><span class="line">  int err = pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="NSConditionLock是通过NSCondition实现的"><a href="#NSConditionLock是通过NSCondition实现的" class="headerlink" title="NSConditionLock是通过NSCondition实现的"></a>NSConditionLock是通过NSCondition实现的</h3><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];</span><br><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    if([cLock tryLockWhenCondition:0])&#123;</span><br><span class="line">        NSLog(@&quot;线程1&quot;);</span><br><span class="line">       [cLock unlockWithCondition:1];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">         NSLog(@&quot;失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [cLock lockWhenCondition:3];</span><br><span class="line">    NSLog(@&quot;线程2&quot;);</span><br><span class="line">    [cLock unlockWithCondition:2];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//线程3</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [cLock lockWhenCondition:1];</span><br><span class="line">    NSLog(@&quot;线程3&quot;);</span><br><span class="line">    [cLock unlockWithCondition:3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>我们在初始化 NSConditionLock 对象时，给了他的标示为0<br> 执行tryLockWhenCondition:时，我们传入的条件标示也是0,所 <strong>以线程1</strong> 加锁成功<br>执行unlockWithCondition:时，<strong>这时候会把condition由0修改为1<br>因为condition修改为了1， 会先走到 </strong>线程3<strong>，然后 </strong>线程3<strong> 又将condition修改为3<br>最后 走了 </strong>线程2** 的流程</p></blockquote><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 模拟代码</span><br><span class="line">- (id) initWithCondition: (NSInteger)value &#123;</span><br><span class="line">    if (nil != (self = [super init])) &#123;</span><br><span class="line">        _condition = [NSCondition new]</span><br><span class="line">        _condition_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的 lockWhenCondition 方法其实就是消费者方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void) lockWhenCondition: (NSInteger)value &#123;</span><br><span class="line">    [_condition lock];</span><br><span class="line">    while (value != _condition_value) &#123;</span><br><span class="line">        [_condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void) unlockWithCondition: (NSInteger)value &#123;</span><br><span class="line">    _condition_value = value;</span><br><span class="line">    [_condition broadcast];</span><br><span class="line">    [_condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>  至此，本文已经对iOS开发中常用的8种锁对了简单的探讨和学习，有几个关键点需要强调的<br>（1）加解锁速度不表示锁的效率，只表示加解锁操作在执行时的复杂程度，因为还需要考虑时间片切换耗时等因素<br>（2）实际开发中，并不是总要选择性能最好的锁来实现，需要根据业务需求和开发成本，代码维护等方面综合选择，这也是@synchronized和NSLock的原因。<br>（3）关于死锁的理解，受文章篇幅影响，暂不分析，可以参考:<a href="http://www.superqq.com/blog/2015/10/16/five-case-know-gcd/" target="_blank" rel="noopener">关于死锁</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;平常项目开发中需要手动加锁的地方少之又少，而且一般是简单粗暴使用@synchronized搞定，不过打算封装框架时就会发现远不满足。本文的目
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
