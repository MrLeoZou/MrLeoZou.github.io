<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MrLeoZou</title>
  
  <subtitle>iOS开发者,大前端学习者</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-11T03:03:41.589Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MrLeoZou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解@property使用的关键字</title>
    <link href="http://yoursite.com/2017/12/11/%E7%90%86%E8%A7%A3-property%E4%BD%BF%E7%94%A8%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/12/11/理解-property使用的关键字/</id>
    <published>2017-12-11T02:57:43.000Z</published>
    <updated>2017-12-11T03:03:41.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>@property是什么<br>众所周知，在iOS开发中，@property是用来声明属性的，默认会自动创建该属性的存储器以及带下划线的成员变量。对于紧随其后的那些关键字也是烂熟于心，信手拈来，但是会用并不代表知道为什么要这样用。</p><h2 id="小Tip"><a href="#小Tip" class="headerlink" title="小Tip"></a>小Tip</h2><h3 id="属性和变量"><a href="#属性和变量" class="headerlink" title="属性和变量"></a>属性和变量</h3><p>在项目中常见的两种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Test : NSObject</span><br><span class="line">&#123;</span><br><span class="line">// 声明变量</span><br><span class="line">NSString *testName;</span><br><span class="line">NSString *testType;</span><br><span class="line">&#125;</span><br><span class="line">// 声明属性</span><br><span class="line">@property(nonatomic,strong) NSString *testName;</span><br><span class="line">@property(nonatomic,strong) NSString *testType;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>以上两种声明的区别在于：<br>（1）声明变量时没有使用到@property，而声明属性时需要用到<br>（2）使用@property声明的属性，默认会自动生成属性的存取器，也就是getter/setter方法，以及带下划线的成员变量；而单独声明变量则没有前者特性。</p><hr><h2 id="property的关键字"><a href="#property的关键字" class="headerlink" title="@property的关键字"></a>@property的关键字</h2><blockquote><p>从大体上我们可以归为三类：原子性，存取控制，内存管理</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="atomic-nonatomic"><a href="#atomic-nonatomic" class="headerlink" title="atomic | nonatomic"></a>atomic | nonatomic</h4><p><strong>1. atomic</strong>:原子性，同一时刻只能有一个线程能访问该属性，在进行属性的get/set时候是安全的。也就是说atomic只能在一定程度上保证线程安全，并不是一定的线程安全。</p><blockquote><p>因为原子属性是保证同一时刻只能有一个线程操作该对象，但是不能保证在一次完整的set -&gt; get操作过程中，只有同一个线程操作。比如，线程A先set该属性，完成后线程B也set了该属性，改变了原来的值，在B完成后A再进行get操作，此时会发现属性的值已经不是当初A线程set进去的，因此会有问题。另外一种更极端的情况是在A线程set完成，B线程进入把该对象release了，等A线程再来访问时就会导致crash。所以想要真正的线程安全，还是需要使用到加锁来实现，具体实现就不在本文的讨论范围了。</p></blockquote><p><strong> 2. nonatomic</strong> :非原子性，顾名思义也就是和atomic含义是相反的。不保证线程安全，可以多个线程同时访问。</p><blockquote><p>小结：在日常开发中，我们绝大部分时候都是使用nonatomic，最主要的原因是nonatomic效率比atomic高很多（坊间传闻约快20倍，具体没有去验证过），因此，在明确只有一个线程访问的情况下推荐使用nonatomic。但是，并不是说任何时候都是用nonatomic，具体要根据实际情况，如果某属性确实存在线程不安全的问题，还是要考虑使用atomic的。</p></blockquote><hr><h3 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h3><h4 id="readwrite-readonly-writeonly"><a href="#readwrite-readonly-writeonly" class="headerlink" title="readwrite | readonly | writeonly"></a>readwrite | readonly | writeonly</h4><ol><li><p>readwrite：可读可写，默认值。同时拥有getter和setter方法</p></li><li><p>readonly：可读不可写，只有getter没有setter方法</p></li><li><p>writeonly：可写不可读，只有setter没有getter方法，很少使用</p></li></ol><p>相对来说，这几个关键字是很简单也容易理解的。</p><hr><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="strong-weak-unsafe-unretained-assign-retain-copy"><a href="#strong-weak-unsafe-unretained-assign-retain-copy" class="headerlink" title="strong | weak | unsafe_unretained | assign | retain | copy"></a>strong | weak | unsafe_unretained | assign | retain | copy</h4><p><strong>1. assign:</strong><br>（1）默认值，用于修饰值类型（基本数据类型），如：int，float，double，CGFloat，NSInteger等。另外就是不存在所有权关系的对象，如：delegate。<br>（2）assign修饰的属性不牵涉内存管理，不会被引用计数器管理。</p><p><strong>2. retain:</strong><br>  ARC后用于取代retain的，作用等同于retain。表示实例变量对传入的对象要有所有权关系，也就是强引用。</p><p><strong>3. strong:</strong><br>ARC后用于取代retain的，作用等同于retain。表示实例变量对传入的对象要有所有权关系，也就是强引用。</p><p><strong>4. weak:</strong><br>针对对象类型，在setter方法中，不会对传入的对象执行引用计数器+1的操作。也就是对传入的对象没有所有权，是弱引用。另外当传入的对象引用计数器为0，也就是被释放后，用weak声明的实例变量会指向nil，即空对象。</p><p><strong>5. unsafe_unretained:</strong><br>（1）从字面上来看，我们可以拆分成两部分来理解，unretained和retain相反，也就是和strong相反，因此等同于weak，其实也是用在iOS5之前替代weak使用的<br>（2）unsafe，不安全的，如上所述等同于weak的话那应该是安全的，这里不安全的是指当传入的对象被释放后，使用unsafe_unretained修饰的变量是不知道的，也不会像weak一样指向nil，所以此时访问可能会引起crash。因此，总结来说unsafe_unretained作用是等同于weak，但是是不安全的。</p><p><strong>6. copy:</strong>在不同情况下会有不同的操作<br>（1）传入的对象是不可变的，如NSString对象<br>  A. 强引用传进来的对象，使其引用计数器+1，等同于strong<br>  B. 该变量指向地址和传入对象的指向地址一致<br>（2）传入对象是可变对象，如NSMutableString对象<br>A. 拷贝一份传入对象，生成一个新的对象，值等同于传入对象值，但是不会强引用传入对象<br>B. 此时变量指向地址就是上述生成的新对象地址，与传入对象地址无关，也不相同；因此，传入对象改变也不会影响到当前变量的值，两者已经是不相干的两个对象了。</p><blockquote><p>关于copy更多深入分析 <a href="http://southpeak.github.io/2015/05/10/ios-techset-1/" target="_blank" rel="noopener">请参考此文</a></p></blockquote><hr><h3 id="几个常见问题"><a href="#几个常见问题" class="headerlink" title="几个常见问题"></a>几个常见问题</h3><h4 id="unsafe-unretained、weak、assign-的区别？"><a href="#unsafe-unretained、weak、assign-的区别？" class="headerlink" title="unsafe_unretained、weak、assign 的区别？"></a>unsafe_unretained、weak、assign 的区别？</h4><ol><li>三者都不会对引用计数器进行操作，都不是对象的拥有者</li><li>unsafe_unretained作用等同于weak，但其实不安全的，不会对传入的对象做赋nil处理，可能产生野指针。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) NSString *strongString;</span><br><span class="line">@property(nonatomic, unsafe_unretained) NSString *unsafe_unretainedString;</span><br><span class="line">self.strongString= [[NSStringalloc] initWithString:&quot;strongString&quot;];</span><br><span class="line">self.unsafe_unretainedString=self.strongString;</span><br><span class="line">self.strongString=nil;</span><br><span class="line">NSLog(@&quot;unsafe_unretainedString == %@&quot;,self.unsafe_unretainedString);</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>这时打印unsafe_unretainedString的值时程序会crash掉。原因是strongString已经释放掉了，但是unsafe_unretainedString并不知道已被释放，所以造成了unsafe_unretainedString访问野指针的内存。</p></blockquote><p>3.assign用于修饰值类型或id，当被释放后如果不手动赋nil，会产生野指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) NSString *strongString;</span><br><span class="line">@property(nonatomic,assign) NSString *assignString;</span><br><span class="line">self.strongString= [[NSString alloc] initWithString:&quot;strongString&quot;];</span><br><span class="line">self.assignString=self.strongString;</span><br><span class="line">self.strongString=nil;</span><br><span class="line">NSLog(@&quot;assignString == %@&quot;,self.assignString);</span><br></pre></td></tr></table></figure></p><blockquote><p>assign的问题和unsafe_unretained类似，可能会产生野指针。</p></blockquote><p>4.weak修饰的变量，当传入的对象被释放后，会自动指向nil，不会产生野指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong) NSString *strongString;</span><br><span class="line">@property(nonatomic,weak) NSString *weakString;</span><br><span class="line">self.strongString= [[NSStringalloc] initWithString:&quot;strongString&quot;];</span><br><span class="line">self.weakString=self.strongString;</span><br><span class="line">self.strongString=nil;</span><br><span class="line">NSLog(@&quot;weakString == %@&quot;,self.weakString);</span><br></pre></td></tr></table></figure></p><blockquote><p>由于 self.strongString与self.weakString指向同一地址，且self.weakString没有retain内存地址，而self.strongString =nil释放 了内存，所以self.strongString为nil。由于self.weakString声明为weak的指针，指针指向的地址一旦被释放，这些指针都将被赋值为nil。这样的好处能有效的防止野指针。</p></blockquote><hr><h4 id="delegate使用assign还是weak，为什么？"><a href="#delegate使用assign还是weak，为什么？" class="headerlink" title="delegate使用assign还是weak，为什么？"></a>delegate使用assign还是weak，为什么？</h4><ol><li>理论上来说，两者都是可以使用的，其一，都不会操作delegate的引用计数器，不是强引用对象。其二，在实际开发中，几乎所有场景下，delegate所指向的对象A的生存期都会被delegate变量B自身的生存期覆盖，也就是说A在使用B的过程中，B都是存在的，因此使用assign也不会有问题。</li><li>但是，由于assign不会处理delegate被释放后的情况，上述的也只是大部分情况，不排除可能会出现delegate被释放了而A还在使用，产生野指针错误，而weak正好会处理这个情况，因此我们一般使用weak来修饰delegate，会更加安全</li></ol><hr><h4 id="self对象是被strong，weak还是其他关键字修饰的？"><a href="#self对象是被strong，weak还是其他关键字修饰的？" class="headerlink" title="self对象是被strong，weak还是其他关键字修饰的？"></a>self对象是被strong，weak还是其他关键字修饰的？</h4><blockquote><p>在实际开发中，我们随处可见[self testMothod];这种写法，但是真正去思考self的生命周期和内存管理的估计很少。试问假如self在方法执行的过程中被释放了，会发生什么？</p></blockquote><p>通过 <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#self" target="_blank" rel="noopener">查阅clang文档</a>，我们发现了关于self的解释：</p><blockquote><p>The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object.<br>To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method.<br>Rationale<br>The cost of retaining self in all methods was found to be prohibitive, as it tends to be live across calls, preventing the optimizer from proving that the retain and release are unnecessary — for good reason, as it’s quite possible in theory to cause an object to be deallocated during its execution without this retain and release. Since it’s extremely uncommon to actually do so, even unintentionally, and since there’s no natural way for the programmer to remove this retain/release pair otherwise (as there is for other parameters by, say, making the variable __unsafe_unretained), we chose to make this optimizing assumption and shift some amount of risk to the user.</p></blockquote><p>上述，self既不是strong也不是weak，而是被unsafe_unretained修饰的，因此要求我们调用的时候保证self是存在的，否则可能会引起无法预料的crash。这样设计的原因是因为在对象方法调用时，我们一定是会把self传递进去，并且在绝大部分情况下做为调用方，我们不会把self释放掉，如果为了处理不到1%情况下的异常而在方法执行时增加retain和release进行保护的话，会对性能有重大影响，因此ARC设计也就没有帮我们处理，需要调用方自行保证self的存在。</p><blockquote><p>以上便是对iOS常用的property后关键字的分析理解。另外，关于copy和block的使用和探讨将在后续的文章进行，这块较复杂内容也较多。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;@property是什么&lt;br&gt;众所周知，在iOS开发中，@property是用来声明属性的，默认会自动创建该属性的存储器以及带下划线的成员
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中的各种锁</title>
    <link href="http://yoursite.com/2017/12/11/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <id>http://yoursite.com/2017/12/11/iOS开发中的各种锁/</id>
    <published>2017-12-11T01:47:05.000Z</published>
    <updated>2017-12-11T02:49:33.565Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>平常项目开发中需要手动加锁的地方少之又少，而且一般是简单粗暴使用@synchronized搞定，不过打算封装框架时就会发现远不满足。本文的目的是希望站在iOS开发中锁的使用之上的层面分析，探讨各种加锁方式的大致实现原理以及它们之间的区别和性能对比。由于加锁必然涉及到多线程相关知识，所以本文涉猎的知识点可能较多，本着相互学习探讨的心态，希望大家多多指正。</p><p>首先借鉴一张ibireme各种锁性能对比图镇楼，同时也是我们本文的叙述脉络：</p><p><img src="/2017/12/11/iOS开发中的各种锁/lock_01.png" alt="来源：ibireme"><br>上图，Y轴从下到上性能越来越来，越来越接近底层，平时使用也越来越少o(╯□╰)o。接下来我们将从我们最熟悉的@synchronized说起，逐步深入，步步为营。</p><hr><p>在开始分析之前，有几个概念需要先拎出来溜溜，方便后文理解。</p><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p> <a href="http://baike.baidu.com/view/3186651.htm" target="_blank" rel="noopener">时间片轮转调度算法</a><br>这是目前操作系统中大量使用的线程管理方式，大致就是操作系统会给每个线程分配一段时间片（通常100ms左右）这些线程都被放在一个队列中，cpu只需要维护这个队列，当队首的线程时间片耗尽就会被强制放到队尾等待，然后提取下一个队首线程执行。</p><hr><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>“原子”：一般指最小粒度，不可分割；原子操作也就是不可分割，不可中断的操作。我们最重要是知道这个概念，至于具体实现就不在本文的讨论范围。可以参考以下文章：<br><a href="http://www.jianshu.com/p/cb7b726e943c" target="_blank" rel="noopener">原子操作01</a><br><a href="http://southpeak.github.io/2014/10/17/osatomic-operation/" target="_blank" rel="noopener">原子操作02</a><br>至此，我们正式进入iOS开发中各种锁的探讨。</p><hr><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h2><p>显然，这是我们最熟悉的加锁方式，因为这是OC层面的为我们封装的，使用起来简单粗暴。使用时 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(也就是锁池)，通过对对象去哈希值来得到对应的互斥锁。<br>对于@synchronized更深入的实现理解，这里<a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">@synchronized</a>会有更好的答案。</p><hr><h2 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock 自旋锁"></a>OSSpinLock 自旋锁</h2><p>首选作为效率最优选择的OSSpinLock是自旋锁，在 bireme 的<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a>文中，已经指出潜在的bug：优先级反转，因此目前不建议使用。<a href="http://baike.baidu.com/link?url=T9Im_xVyniC5SdvZVH1Y1iEgkFhcjGm-Hnme803oWgRi3vZa1JVMy-RsljCPDuvPiOcWIrrUedw7CLYRjqhWtuO4CLSgugUUPoHrCKsB-T2GNionyGgXYRUaJ43joO6ZeGGvxIDsW6s2ham_x1vkv_" target="_blank" rel="noopener">什么是优先级反转？</a><br>自旋锁的目的是为了确保临界区只有一个线程可以访问，自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，自旋锁是使用忙等机制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool lock = false; // 一开始没有锁上，任何线程都可以申请锁</span><br><span class="line">do &#123;</span><br><span class="line">while(test_and_set(&amp;lock); // test_and_set 是一个原子操作</span><br><span class="line">Critical section  // 临界区</span><br><span class="line">lock = false; // 相当于释放锁，这样别的线程可以进入临界区</span><br><span class="line">Reminder section // 不需要锁保护的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果临界区的执行时间过长，不建议使用自旋锁，因为在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。</p><hr><h2 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore  信号量"></a>dispatch_semaphore  信号量</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p><strong>dispatch_semaphore_create(1)：</strong>传入值必须&gt;=0, 若传入为0则阻塞线程并等待timeout,时间到后会执行其后的语句<br><strong>dispatch_semaphore_wait(signal, overTime)：</strong>可以理解为lock,会使得signal值-1<br><strong>dispatch_semaphore_signal(signal)：</strong>可以理解为unlock,会使得signal值+1</p></blockquote><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote><p>停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。<br><strong>信号量的值（signal）</strong>就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，dispatch_semaphore_signal就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），调用一次 dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait 剩余车位就减少一个；当剩余车位为 0 时，再来车（即调用 dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，所以就一直等下去。</p></blockquote><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>参考<a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="noopener">介绍 GCD 底层实现的文章</a>中简单描述了信号量 dispatch_semaphore_t 的实现原理，它最终会调用到 sem_wait 方法，这个方法在 <a href="http://www.gnu.org/software/libc/" target="_blank" rel="noopener">glibc</a> 中被实现如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int sem_wait (sem_t *sem) &#123;</span><br><span class="line">  int *futex = (int *) sem;</span><br><span class="line">  if (atomic_decrement_if_positive (futex) &gt; 0)</span><br><span class="line">    return 0;</span><br><span class="line">  int err = lll_futex_wait (futex, 0);</span><br><span class="line">    return -1;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><blockquote><p>首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在lll_futex_wait<br>函数中实现，<strong>lll</strong> 是 low level lock 的简称。这个函数通过汇编代码实现，调用到SYS_futex<br>这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。<br>主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。<br>可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</p></blockquote><h2 id="pthread-mutex-互斥锁"><a href="#pthread-mutex-互斥锁" class="headerlink" title="pthread_mutex 互斥锁"></a>pthread_mutex 互斥锁</h2><p>pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换。</p><h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL);  // 定义锁的属性</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁</span><br><span class="line">pthread_mutex_lock(&amp;mutex); // 申请锁</span><br><span class="line">    // 临界区</span><br><span class="line">pthread_mutex_unlock(&amp;mutex); // 释放锁</span><br></pre></td></tr></table></figure><h3 id="互斥锁的实现"><a href="#互斥锁的实现" class="headerlink" title="互斥锁的实现"></a>互斥锁的实现</h3><blockquote><p>互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。<br>上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 test_and_test，这样可以在错误使用互斥锁时提高性能。</p></blockquote><hr><h2 id="pthread-mutex-recursive-递归锁"><a href="#pthread-mutex-recursive-递归锁" class="headerlink" title="pthread_mutex(recursive)  递归锁"></a>pthread_mutex(recursive)  递归锁</h2><p>一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。<br>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己，由此也就引出了递归锁：<strong>允许同一个线程在未释放其拥有的锁时反复对该锁进行加锁操作。</strong></p><p>递归锁的使用和pthread_mutex很类似，主要就是要设置锁的类型为PTHREAD_MUTEX_RECURSIVE即可。</p><blockquote><p>由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。</p></blockquote><hr><h2 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h2><p>NSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define    MLOCK \</span><br><span class="line">- (void) lock\</span><br><span class="line">&#123;\</span><br><span class="line">  int err = pthread_mutex_lock(&amp;_mutex);\</span><br><span class="line">  // 错误处理 ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>NSLock只是在内部封装了一个pthread_mutex，属性为PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部pthread_mutex互斥锁的类型不同。通过宏定义，可以简化方法的定义。<br>NSLock比pthread_mutex略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。</p><hr><h2 id="NSRecursiveLock-递归锁"><a href="#NSRecursiveLock-递归锁" class="headerlink" title="NSRecursiveLock 递归锁"></a>NSRecursiveLock 递归锁</h2><p>前文我们已经介绍过，递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型。NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE。</p><hr><h2 id="NSConditionLock-条件锁"><a href="#NSConditionLock-条件锁" class="headerlink" title="NSConditionLock 条件锁"></a>NSConditionLock 条件锁</h2><p>NSCondition的底层是通过条件变量(condition variable)pthread_cond_t来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。<a href="https://zh.wikipedia.org/wiki/生产者消费者问题" target="_blank" rel="noopener">关于生产者消费者问题</a></p><h3 id="条件变量使用"><a href="#条件变量使用" class="headerlink" title="条件变量使用"></a>条件变量使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void consumer () &#123; // 消费者</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while (data == NULL) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据</span><br><span class="line">    &#125;</span><br><span class="line">    // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓</span><br><span class="line">    // temp = data;</span><br><span class="line">    // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void producer () &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    // 生产数据</span><br><span class="line">    pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，告诉他们有了新的数据</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。</p><h3 id="这也就是NSCondition的实现原理："><a href="#这也就是NSCondition的实现原理：" class="headerlink" title="这也就是NSCondition的实现原理："></a>这也就是NSCondition的实现原理：</h3><p>NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者。NSCondition的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void) signal &#123;</span><br><span class="line">  pthread_cond_signal(&amp;_condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其实这个函数是通过宏来定义的，展开后就是这样</span><br><span class="line">- (void) lock &#123;</span><br><span class="line">  int err = pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="NSConditionLock是通过NSCondition实现的"><a href="#NSConditionLock是通过NSCondition实现的" class="headerlink" title="NSConditionLock是通过NSCondition实现的"></a>NSConditionLock是通过NSCondition实现的</h3><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];</span><br><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    if([cLock tryLockWhenCondition:0])&#123;</span><br><span class="line">        NSLog(@&quot;线程1&quot;);</span><br><span class="line">       [cLock unlockWithCondition:1];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">         NSLog(@&quot;失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [cLock lockWhenCondition:3];</span><br><span class="line">    NSLog(@&quot;线程2&quot;);</span><br><span class="line">    [cLock unlockWithCondition:2];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//线程3</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    [cLock lockWhenCondition:1];</span><br><span class="line">    NSLog(@&quot;线程3&quot;);</span><br><span class="line">    [cLock unlockWithCondition:3];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>我们在初始化 NSConditionLock 对象时，给了他的标示为0<br> 执行tryLockWhenCondition:时，我们传入的条件标示也是0,所 <strong>以线程1</strong> 加锁成功<br>执行unlockWithCondition:时，<strong>这时候会把condition由0修改为1<br>因为condition修改为了1， 会先走到 </strong>线程3<strong>，然后 </strong>线程3<strong> 又将condition修改为3<br>最后 走了 </strong>线程2** 的流程</p></blockquote><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 模拟代码</span><br><span class="line">- (id) initWithCondition: (NSInteger)value &#123;</span><br><span class="line">    if (nil != (self = [super init])) &#123;</span><br><span class="line">        _condition = [NSCondition new]</span><br><span class="line">        _condition_value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它的 lockWhenCondition 方法其实就是消费者方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void) lockWhenCondition: (NSInteger)value &#123;</span><br><span class="line">    [_condition lock];</span><br><span class="line">    while (value != _condition_value) &#123;</span><br><span class="line">        [_condition wait];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void) unlockWithCondition: (NSInteger)value &#123;</span><br><span class="line">    _condition_value = value;</span><br><span class="line">    [_condition broadcast];</span><br><span class="line">    [_condition unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>  至此，本文已经对iOS开发中常用的8种锁对了简单的探讨和学习，有几个关键点需要强调的<br>（1）加解锁速度不表示锁的效率，只表示加解锁操作在执行时的复杂程度，因为还需要考虑时间片切换耗时等因素<br>（2）实际开发中，并不是总要选择性能最好的锁来实现，需要根据业务需求和开发成本，代码维护等方面综合选择，这也是@synchronized和NSLock的原因。<br>（3）关于死锁的理解，受文章篇幅影响，暂不分析，可以参考:<a href="http://www.superqq.com/blog/2015/10/16/five-case-know-gcd/" target="_blank" rel="noopener">关于死锁</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;平常项目开发中需要手动加锁的地方少之又少，而且一般是简单粗暴使用@synchronized搞定，不过打算封装框架时就会发现远不满足。本文的目
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
